#version 430 core

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D uImageOutput;

uniform vec2 uCameraPosition;
uniform float uCameraScale;
uniform vec4 uBaseColor;

uniform vec4 uLightColor[128];
uniform vec3 uLightData[128];
uniform int uLightCount;

void main() {
  vec4 color = uBaseColor;
  vec2 size = vec2(imageSize(uImageOutput));

  vec2 coords = vec2( 
    (float(gl_GlobalInvocationID.x) - size.x * 0.5) * uCameraScale + uCameraPosition.x,
    (size.y * 0.5 - float(gl_GlobalInvocationID.y)) * uCameraScale + uCameraPosition.y
  );

  float weights = 0;
  float maxWeight = 0.0;
  vec4 combinedColor = vec4(0.0, 0.0, 0.0, 0.0);
  for (int i = 0; i < uLightCount; i++) 
  {
    float dist = distance(uLightData[i].xy, coords);
    if (dist < uLightData[i].z)
    {
      float x = dist / uLightData[i].z;
      float weight = 1.0 - x*x*x;
      combinedColor += uLightColor[i] * weight;
      weights += weight;
      if (weight > maxWeight)
      {
        maxWeight = weight;
      }
    }
  }

  if (weights > 0)
  {
    // TODO fix the slightly visible darkness when lights overlap
    // the maxWeight currently is the max distance from the pixel to the edge of light
    // and it should take into account that when lights overlap, that distance should be
    // calculated as the max distance from the pixel to the closest edge of the combined lights
    color = mix(vec4(uBaseColor.rgb, 1.0), combinedColor / weights, maxWeight);
  }

  imageStore(uImageOutput, ivec2(gl_GlobalInvocationID.xy), vec4(color.rgb, uBaseColor.a));
}