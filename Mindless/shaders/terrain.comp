#version 430 core

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D uImageOutput;

uint hash( uint x ) {
  x += ( x << 10u );
  x ^= ( x >>  6u );
  x += ( x <<  3u );
  x ^= ( x >> 11u );
  x += ( x << 15u );
  return x;
}

uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

float floatConstruct( uint m ) {
  const uint ieeeMantissa = 0x007FFFFFu;
  const uint ieeeOne      = 0x3F800000u;

  m &= ieeeMantissa;
  m |= ieeeOne;

  float  f = uintBitsToFloat( m );
  return f - 1.0;
}

float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

float noise(vec2 uv) 
{
  vec2 lv = fract(uv);
  vec2 id = floor(uv);
  
  lv = lv*lv*(3.-2.*lv);
  
  float bl = random(id);
  float br = random(id+vec2(1,0));
  float b = mix(bl, br, lv.x);
  
  float tl = random(id+vec2(0,1));
  float tr = random(id+vec2(1,1));
  float t = mix(tl, tr, lv.x);
  
  return mix(b, t, lv.y);
}

float biome(float moisture, float height)
{
  if (height < 0.1)
    return 0.0; // ocean
  if (height < 0.15)
    return 0.1; // shallow water
  if (height < 0.2)
    return 0.2; // beach
  if (height < 0.6)
  {
    if (moisture < 0.33)
      return 0.31; // desert
    if (moisture < 0.67)
      return 0.32; // grassland
    return 0.33; // dense forest (tropical)
  }
  if (height < 0.65)
    return 0.4; // shrubland
  if (height < 0.7)
    return 0.5; // hills
  return 0.6; // mountain top (snow)
}

uniform sampler2D uBiomesMap;
uniform float uScale;
uniform int uOctaves;
uniform float uPersistence;
uniform float uLacunarity;
uniform vec2 uHalfSize;
uniform vec2 uOctaveOffsets[6];

void main()
{
  float amplitude = 1.0;
  float frequency = 1.0;
  float noiseHeight = 0.0;
  float noiseMoisture = 0.0;

  // this could be calculated by the CPU
  float maxPossibleHeight = 0.0;
  float minPossibleHeight = 0.0;

  for (int i = 0; i < uOctaves; i++)
  {
    vec2 samplePosition = (vec2(gl_GlobalInvocationID.xy) - uHalfSize) / uScale * frequency;
    samplePosition += uOctaveOffsets[i];

    float height = noise(samplePosition) * 2.0 - 1.0;
    noiseHeight += height * amplitude;

    float moisture = noise(samplePosition + vec2(83572.43, -35724.34)) * 2.0 - 1.0;
    noiseMoisture += moisture * amplitude;

    maxPossibleHeight += amplitude;
    minPossibleHeight -= amplitude;

    amplitude *= uPersistence;
    frequency *= uLacunarity;
  }
  // normalize
  noiseHeight = (noiseHeight - minPossibleHeight) / (maxPossibleHeight - minPossibleHeight);
  noiseMoisture = (noiseMoisture - minPossibleHeight) / (maxPossibleHeight - minPossibleHeight);

  // force water
  float d = length((vec2(gl_GlobalInvocationID.xy) - uHalfSize) / uScale) / sqrt(0.5) / 3.0;
  noiseHeight = (1.0 + noiseHeight - d) / 2.0;

  maxPossibleHeight = (1.0 + maxPossibleHeight) / 2.0;
  minPossibleHeight = (1.0 + minPossibleHeight - 2.0) / 2.0;

  // normalize again
  noiseHeight = (noiseHeight - minPossibleHeight) / (maxPossibleHeight - minPossibleHeight);

  // imageStore(uImageOutput, ivec2(gl_GlobalInvocationID.xy), vec4(texture(uBiomesMap, vec2(noiseMoisture, 1.0 - noiseHeight)).rgb, 1.0));
  imageStore(uImageOutput, ivec2(gl_GlobalInvocationID.xy), vec4(noiseHeight, noiseMoisture, biome(noiseMoisture, noiseHeight), 1.0));
}